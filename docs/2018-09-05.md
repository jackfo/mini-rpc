# zookeeper处理流程


RegistryFactory工厂会通过SPI其适配类 适配类再根据URL获取相应的实现类 这里以ZookeeperRegistryFactory为例


ZookeeperRegistryFactory调用createRegistry[需要注意的是在ZookeeperRegistryFactory创建时候其setter方法会通过SPI获取ZookeeperTransporter]





# 服务暴露处理流程

  服务暴露主要是通过服务模型进行bind
  
  目前在Exchanger
  
  从MiniProtocol的openServer开始进行暴露服务
  
  createServer创建服务
  
  Exchangers.bind(url, requestHandler); 添加一个相应的请求句柄
  
  return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
  在这一步加了几个通道句柄之后调用Transporters进行bind
  实际的Transporters实现类是通过SPI获取 
  
  以Netty为例最终获取的是NettyTransporter,其bind方法如下,最终创建了一个NettyServer
  public Server bind(URL url, ChannelHandler listener) throws RemotingException {
          return new NettyServer(url, listener);
  }
  注意:在其继承类AbstractEndpoint会获取相应的编解码通道
   
  在NettyServer中创建实例会调用到其继承抽象类AbstractServer 在其里面会通过模板方法调用doOpen从而开启相应的服务